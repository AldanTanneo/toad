open MenhirLib
open Toad

let build ?(core = false) filename canon_env typing_env =
  let contents, lexbuf =
    if core then (
      let lexbuf = Lexing.from_string filename in
      Lexing.set_filename lexbuf "core.toad";
      (filename, lexbuf))
    else LexerUtil.read filename
  in
  let buffer, lexer = ErrorReports.wrap Lexer.lex in
  let module_name =
    if core then Types.core
    else Filename.remove_extension (Filename.basename filename)
  in
  try
    let program = Parser.program lexer lexbuf in
    let p, canon_env =
      Canonicalize.canonicalize module_name program canon_env
    in
    let ir, types, tenv = Typecheck.type_program module_name p typing_env in
    (canon_env, tenv, (ir, types))
  with
  | Canonicalize.UnboundIdentifier item ->
      Format.eprintf "%s: Unbound identifier: %a\n%!" filename Printers.pp_item
        item;
      exit 1
  | Canonicalize.UnboundType ty ->
      Format.eprintf "%s: Unbound type: %a\n%!" filename Printers.pp_type ty;
      exit 1
  | Canonicalize.UnspecifiedType ty ->
      Format.eprintf "%s: Unspecified type in definition: %a\n%!" filename
        Printers.pp_type ty;
      exit 1
  | Canonicalize.ImplNonLocal ty ->
      Format.eprintf "%s: Could not find type %a in the current namespace"
        filename Printers.pp_type ty;
      exit 1
  | Unify.Cycle (v_name, ty) ->
      Format.eprintf "%s: Unification cycle: %s is present in %a\n%!" filename
        v_name Printers.pp_type ty;
      exit 1
  | Unify.RefConflict (t1, t2) | Unify.Conflict (t1, t2) ->
      Format.eprintf
        "%s: Unification conflict: types %a and %a are incompatible\n%!"
        filename Printers.pp_type t1 Printers.pp_type t2;
      exit 1
  | Typecheck.UnknownField (ty, s) ->
      Format.eprintf "%s: Unknow field: type %a does not have a %s field\n%!"
        filename Printers.pp_type ty s;
      exit 1
  | Failure msg ->
      Printf.eprintf "%s: Error: %s\n\n%!" filename msg;
      exit 1
  | Parser.Error ->
      let pos = ErrorReports.last buffer in
      let range = LexerUtil.range pos in
      let get_token pos =
        ErrorReports.extract contents pos
        |> ErrorReports.sanitize |> ErrorReports.compress
        |> ErrorReports.shorten 20
      in
      let show = ErrorReports.show get_token buffer in
      Printf.eprintf "%sParsing error %s.\n%!" range show;
      exit 1
  | Lexer.LexError (msg, pos1, pos2) ->
      let range = LexerUtil.range (pos1, pos2) in
      Printf.printf "%sLexing error: %s\n%!" range msg;
      exit 1

let main () =
  Cli.parse ();
  let canon_core, typing_core, (ir, types) =
    build ~core:true Bundled.core (ref Types.Env.init) (ref Types.Env.init)
  in
  let canon_env = ref canon_core in
  let typing_env = ref typing_core in
  let ir, types =
    List.fold_left
      (fun (ir, types) filename ->
        let _, _, (ir', types') = build filename canon_env typing_env in
        (ir @ ir', types @ types'))
      (ir, types) !Cli.input_files
  in
  let ir = List.rev ir and types = List.rev types in
  let generated_filename =
    Filename.remove_extension
      (Filename.basename (List.hd (List.rev !Cli.input_files)))
  in
  let out = "/tmp/" ^ generated_filename ^ ".generated.c" in
  let oc = Format.formatter_of_out_channel (open_out out) in
  Format.fprintf oc
    "@[<v>// Generated by toadc %s@;\
     @;\
     %s@;\
     @;\
     static char **__toad_argv;@;\
     static int __toad_argc;@;\
     @;"
    Cli.version Bundled.prelude;
  let entry_point = Codegen.gen oc ir types in
  Format.fprintf oc
    "@;\
     int main(int argc, char * argv[]) {@;\
    \  GC_INIT();@;\
    \  __toad_argv = argv;@;\
    \  __toad_argc = argc;@;\
    \  %s();@;\
    \  return 0;@;\
     }@;\
     @]%!"
    entry_point;
  Format.pp_print_flush oc ();

  let cc = Option.value ~default:"cc" (Sys.getenv_opt "CC") in

  let ret =
    Sys.command
      (Printf.sprintf "%s %s -lgc -o %s%s" cc out !Cli.output_file
         (List.fold_left (fun acc s -> acc ^ " " ^ s) "" !Cli.cflags))
  in
  let _ = Sys.command (Printf.sprintf "clang-format -i %s" out) in

  exit ret
;;

try if !Sys.interactive then () else main () with
| Failure s ->
    Printf.eprintf "Error: %s\n%!" s;
    exit 1
| Codegen.ImplMoreGeneral (it1, it2) ->
    Format.eprintf "Specialisation error: %a is more general than %a.\n%!"
      Printers.pp_item it1 Printers.pp_item it2;
    exit 1
| Codegen.DifferentSignature ((it1, t1), (it2, t2)) ->
    Format.eprintf
      "Specialisation error: function %a of type %a is incompatible with %a of \
       type %a.\n\
       %!"
      Printers.pp_item it1 Printers.pp_type t1 Printers.pp_item it2
      Printers.pp_type t2;
    exit 1
